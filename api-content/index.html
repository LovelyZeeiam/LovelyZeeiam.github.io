{"posts":[{"title":"Minecraft基岩版存档格式简介（未完成）","content":"花絮： 今天的bgm是什么呢？ 啊 是sans.（ 目录 [TOC] 写在前面 人在家中，刚下床，谢邀。本专栏由&quot;基本&quot;不会编程的up🐖书写，许多专业术语知识还欠缺，可能会有错误，还请大佬们见谅。 许多时候程序yuan并不会那么bt，许多在编程中用到数据的命名肯定都和英语有一部分关系，mc的level.dat就是一个例子。 存档全局信息 网上关于修改level.dat的教程其实害挺多的，沃这里就一笔带过一下Awawawa~ level.dat是以未经压缩的NBT格式存储的（划重点，java版的level.dat是经过GZIP格式压缩的NBT格式）。NBT全名Named Binary Tag，学过编程的小伙伴可以理解为一个Json数据的结构，没有学过的可以理解成一个数学中的函数——即给出一串文字，有且仅有唯一一个对象与之对应（之类的东西）。 但是捏 (￣▽￣)*，这个文件不是一开始就是nbt数据的开头。这个文件的一开始有留出四个字节。这四个字节会被游戏视为介个level.dat文件的版本号，后续如果要对这个文件的架构进行大的修改就可以通过版本号来判断这个文件是否该升级惹。接下来才是NBT的正文数据。 用NBT修改器打开这个文件，可以根据英文和游戏中敲命令的经历判断出每一个参数的名称对应的是游戏中的什么参数或功能（许多常用的修改都可以通过这个判断）。 存档里面的levelname.txt，这个应该是mojang为了玩家方便查找存档从而创建的一个记录存档名称的文件。但是如果只修改这个文件是达不到修改存档在游戏中显示的名称的。在游戏中修改存档的名称时，游戏会同时改变level.dat内的某个数据和levelname.txt文件；但是仅修改了levelname.txt文件，在游戏中是看不到修改后的存档名称的哦。 world_icon.jpeg是存档图标，长宽分别是400和225. 存档资源包信息 加入过资源包的存档，在该存档的文件夹会出现world_resource_packs.json和world_resource_pack_history.json以及resource_packs文件夹。加入过行为包的存档，会出现world_behavior_packs.json和world_behavior_pack_history.json以及behavior_packs文件夹。 上面提到出现的文件夹是存储这个资源包或行为包的目录，在这个目录里面会有加载过的资源包或行为包，以文件夹的形式放在这个目录下（不是压缩文件哦）。 world_****_packs.json的文件是以Json格式存储。这个Json文件存储了当前这个存档正在使用的包，里面每个包信息的pack_id和version会与包中menifest.json文件中header属性中的pack_id和version对应。 world_****_pack_history.json文件里面存储了至今这个存档使用了那些包。里面每个包的信息会与包中menifest.json文件中header属性中的pack_id和version对应。can_be_redownloaded参数是用来判断这个包是否是商店内下载的包，当这个属性是true的时候，游戏将会去自身的包下载缓存目录寻找这个包，在Windows 10上这个目录是: &quot;C:\\Users\\宁的用户名\\AppData\\Local\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\&quot; 但是里面几乎所有的内容都被加密辽，，，。这个目录里面还有一个persona文件夹，应该是存储了在游戏内自定义皮肤的里面的信息。skin_packs文件夹里面存储的是皮肤包。手机root不了所以看不到在哪里，有兴趣的小伙伴可以去手机的根目录找找（大家平时打开手机自身的文件管理器打开的不是根目录**!!!**沃记得的ES文件管理器和MT管理器都可以看到手机根目录的文件) 值得注意的是，开发者可以将自己要测试的包放在com.mojang文件夹下面的development_****_packs文件夹下面。放在这里的包在游戏中导入时，是不会被复制到存档自身的****_pack文件夹里面的哦。所以，如果是边开发边测试一个包，可以直接在development_****_packs文件夹里面创建一个文件夹作为存储这个包的地方，导出这个包时直接将这个文件夹里面的所有文件压缩就可以啦。 NBT格式概述 【本节涉及到小字节序和大字节序，然后up不会讲,,,大家可以去看https://zhuanlan.zhihu.com/p/21388517的&quot;2.2 字节序&quot;一节】 Minecraft在java版和基岩版的数据存储都或多或少的使用了NBT格式。在这里简单的说明一下NBT格式是个什么东西。首先得先说明一下，这种格式是可以嵌入的，不仅仅是在一个文件里面，还可以存在于一个文件的一部分。上面提到过，NBT全名Named Binary Tag，学过编程的小伙伴可以理解为一个Json数据的结构，没有学过的可以理解成一个数学中的函数——即给出一串文字，有且仅有唯一一个对象与之对应（之类的东西）。在这里我们会来探讨这些数据是如何存储的。（notch提供的nbt.txt说明文档国内好像上不去，能得到这个文件的好心人可以把原文或者网盘地址放在评论区嘛，蟹蟹！~，地址：web.archive.org/web/20110723210920/http://www.minecraft.net/docs/NBT.txt） 既然叫Named Binary Tag，咱们肯定先得看看一个Tag怎么存储。一个Tag的第一个字节代表这个Tag的类型，第二个字节和第三个字节在一起以大字节序组成一个数字，是这个Tag名字的长度。接下来跟着的就是这个Tag的内容，在百度百科叫做辅助信息。 来自百度百科 - NBT （二进制命名标签） 存档其它信息 其它的信息包括地形信息，方块内部特有的信息，实体信息等等（或许概括全了）都存在&quot;db&quot;文件夹里面。这个文件夹里面存储的是一个LevelDB数据库（以下简称数据库）。与NBT类似，也是给出一个值，会返回另外一个唯一的值（程序员: 不就是key-value数据库嘛）。 （偷个懒 技术玩家可以通过直接写代码的方式来访问这个数据库 其ta的玩家捏可以通过MCC ToolChest打开这个存档 不过后者可能可见的信息要少一些） 既然给出一个值(key)就返回另外一个唯一的值(value)，那么我们肯定得先从给出的这个值开始入手。咱们从简单的开始。 计分板 计分板肯定得算比较简单的。直接向这个数据库里面传入&quot;scoreboard&quot;中每个字母的ascii码组成的数组就可以（Java: &quot;scoreboard&quot;.getBytes() 后 遗 症)，获取到一个未经压缩的小字节序NBT数据。这个数据中会存储着5个数据: 五个数据哦~ 玩家 游戏中，玩家肯定也是不可少的一部分（废话）。修改玩家的信息也足够简单，不过获取一个玩家的信息是一件难事。目前还未发现比较轻便的查找对应玩家信息的方法。 在数据库中，得到本地玩家的玩家信息要传的参数为&quot;~local_player&quot;； 得到真正的玩家信息要传的参数为&quot;player_********-****-****-****-************&quot;； 当然也会有一种玩家信息是带server的，这种应该是基岩版官方服务器的存档内存储的玩家信息，要传的参数为&quot;player_server_********-****-****-****-************&quot;（下划线和横杠杠不要看错了沃）。（星号组成一个uuid 大概是游戏随机分配的） （老爹：还有一件事：要传的是这些文字的ASCII码组成的数组!） 三种情况得到的都是一个小字节序的NBT数据。第一种情况和第三种情况得到的NBT数据大致上都应该相同（常用的参数应该都拥有）。第二种情况可能会得到只含三个参数的NBT标签： ​ MsaId和SelfSignedId： 这两个标签似乎都有可能与ta所在标签的名称相同，目前未找到用途； ​ ServerId： 可以直接将这个数据传进数据库，会得到上面提到的第三种情况的数据. 得到的玩家的NBT数据可以直接根据其名称来判断这个属性控制的是游戏中的什么功能（学英文的重要性（ε=┏(゜ロ゜;)┛）） 其它看不懂的，大部分都有可能是一修改就出问题 或是无实际功能或修改价值 抑或是没修炼够/doge： （当然可能也可以通过修改这个来达到使玩家pregnant的臆想效果（ 地图 像素画大师们最钟情（可能）的东西。在数据库中，要想找到一个指定的地图并非容易。得到一个地图数据需要传的参数的格式: &quot;map_&quot;+一串数字。如果单纯看这串十进制的数据，是比较难发现规律的。我们将其变成16进制康康： 不难发现（），这串数字的前四位与FF FF FF FF代表的数字相差加上1，即为在创建这个地图的时候进游戏的次数。不过这串数字后四个字节就非常非常神奇，观测是离关游戏的时间越近，这四个字节在大端序下代表的数字就会越小。 并且有时候总会有5个地图的id是连续的。呐是因为呀，当玩家在游戏中创建了一个地图后，游戏内部会新增5个这样连续的id代表5个不同的地图数据。这5个不同的数据代表了该地图的5个级别，就算玩家没有主动去合成其它四个不同级别的地图。 【似乎只能通过玩家手里拿的物品来找到指定的地图了】 我们通过键得到的仍然是一个小字节序的未经压缩的NBT数据。里面可以进行大肆（雾）修改的就是colors数据。这个colors记录了地图128*128图片大小的数据，先从左到右存储图片的第一行像素，依次向图片下方存储。其中每四个字节分别对应r,g,b,a的值，代表一个像素。 地图里面还存储了decorations数据，类型是Compound Tag，这里存储的是地图上面的有些装饰，这个数据里面还存储了2个Compound Tag叫data和key。key里面存储的是这个装饰的世界位置和类型，data里面存储了这个装饰的方向(rot)，类型(type)和相对于地图的位置（？x, y)。 修改完成地图后，不要忘了把dimension调成-1噢~ 调成-1后，游戏内就对这个地图的修改撒手了。 还有一些其ta的 可以在这里找到: https://minecraft.gamepedia.co/Bedrock_Edition_level_format#Other_keys （是英文的 Awa） 地形存储 【本节内容可能会有不对的地方 也请大佬们在评论底下修正 非常感谢！】 终于到我们的重头戏了——游戏的地形存储。今天小编就来带大家看看。 首先还是我们的惯例，灵魂疑问：该怎么得到区块的信息呢？真的很简单，人人都可以学得会：首先将这个区块的x坐标以小字节序变成四个字节（即一个int类型）然后将这个区块的z坐标也以小字节序变成四个字节紧随其后，如果这个区块不是主世界区块那就再将其维度对应的id以小字节序还是变成四个字节跟在后面（1是地狱，2是末地），然后后面跟上一个特定的数字以一个字节存储的字节。这个特定的数字可以是下面的任意一个，取决于要申请的数据的类型：【下面有一类数据，只传这个特定的数字是拿不到滴，下面会有解释】 例： 如果想要申请x坐标是114514，z坐标是1919180的区块的高度图（臭味图（逃）和生物群系: 高度图和生物群系 ​ 申请得到的高度图和生物群系中，前512个字节存储的是高度图。高度图存储了俯视这个区块得到的平面图中，每一格存储一个short类型（一个占两个字节的整数）代表这一格最高的方块处在的y坐标。紧接着是生物群系，以同样的方式，但是是以每一格一个byte类型存储生物群系id。 左图:mcc tool chest pe截图 横坐标是x 纵坐标是z 右图:从数据库中取出的数据在十六进制编辑器中的模样 方块实体数据 申请得到的方块实体数据是一个小字节序的NBT数据。 有些方块为了每一个游戏刻都要刷新，所以将其归结到方块实体里面；还有一些功能方块，存储的数据比较多，所以就存在了这里，具体为什么要放在下面的地形数据再说啦~ 由于未在minecraft维基上面找到每个方块实体存储的信息（抑或是我没找到），于是沃自己整理了一下： （以下内容按照CC BY-NC-SA 3.0协议分享） 旗帜 Base: (Integer) 旗帜的背景颜色 id: (String) 应该都是banner x, y, z: (Integer) 旗帜所占用的方块所在坐标 【这个参数是每个方块实体数据都有的哦 下面就不写啦】 isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 Type: (Integer) 还未发现其用处 蜂巢，蜂箱 （沃用summon指令创建多只蜜蜂然后游戏就卡死辽？？） id: (String) 应该都是Beehive isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 Occupants: (List) 指的是这个beehive里面存储了什么东西。里面存储的都是Json对象。每个Json对象包括: ActorIdentifier: (String) 当这个值为&quot;minecraft:bee&lt;&gt;&quot;时，代表这是一只可爱的小蜜蜂~ （也没发现可以存什么其它的值呀/xk 不过保持严谨就对(个鬼)） TicksLeftToStay: (Integer) 表示从此刻开始多少个游戏刻之后蜜蜂就会跑粗来 SaveData: (Compound) 当&quot;ActorIdentifier&quot;是”minecraft:bee&lt;&gt;“时，这里直接存储了这个蜜蜂的实体NBT，如下图: 牌子 id: (String) 一直都是&quot;Sign&quot;的说~ isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 Text: (String) 牌子上面写的字 换行使用&quot;\\n&quot; TextOwner: (String) 这个值似乎跟编辑这个牌子的玩家有关，但是好像又在玩家的nbt里面找不到与这段文字相同的内容,,,（或许是由于今天是开学前一天沃写的比较急就没有认真找的缘故吧） 箱子，陷阱箱，漏斗，投掷器，发射器，潜影盒 id: (String) 一直都是&quot;Chest&quot;的 isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 Items: (List) 存储了箱子里面的东西。这跟玩家物品栏的存储类似，就是只有当这一格有物品时，游戏才会将其存储到存档里面。当没有存放物品的时候，游戏会将这个存储成一个长度为0的空列表。当向里面存放物品的时候，游戏回家原封不动地将物品的NBT复制到这里面来，并加上一个Byte类型的Slot标签。 （仅漏斗） TransferCooldown: (Integer) 猜测是当漏斗传输完一个物品，这个值就会变成漏斗传输物品的冷却tick数，每个tick对这个数递减，当这个数变成0之后就传输下一个物品。还未得到证实（因为太难证实了啊啊啊） （仅箱子，陷阱箱，潜影盒） Findable: (Byte) 似乎没什么用的亚子，默认是0 （仅潜影盒） facing: (Byte) 潜影盒的朝向，如下表: 方向 上 下 东 西 南 北 &quot;facing&quot;值 1 0 5 4 3 2 例： 一个箱子的NBT: 篝火，灵魂篝火 id: (String) &quot;Campfire&quot;没得洗 isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 Items1, Items2, Items3, Items4: (Compound) 是篝火的四个槽位。当这上面没有物品时，游戏就不会存储这个Tag。并且与箱子不同的是，这里并不会增加Slot标签。玩家向篝火上面沿着逆时针放物品。 ItemTime1, ItemTime2, ItemTime3, ItemTime4: (Integer) 对应的篝火的四个槽位的已经进行烧烤（）的游戏tick数。 例： 一个篝火的方块实体NBT: 酿造台 id: (String) &quot;BrewingStand&quot;没得洗 isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 CookTime: (Short) 烹饪时间（才怪）是离炼完这次药还有多少的游戏tick。 FuelAmount: (Short) 燃料的数量。装入一个烈焰粉，会让这个数变成20。炼一次药，会让这个数减去一。当这个数为0时，就代表燃料耗尽，能不能再炼药了。 FuelTotal: (Short) 观测一直是20，大概是开发者忘了删掉这个吧。 Items: (List) 跟箱子的Items存储类似，但是在里面炼出来的药水会多出来一个标签： 酿造台中每个槽所代表的位置放在下图: 例： 一个正在酿造的酿造台的方块实体NBT: 熔炉，烟熏炉，高炉 id: (String) 熔炉 烟熏炉 高炉 Furnace Smoker BlastFurnace isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 CookTime: (Short) 当前物品离烧完成还需多少游戏tick BurnTime: (Short) 当前燃料还可以燃烧多少游戏tick StoredXPInt: (Integer) 炉子里面存储的经验数量 Items: (List) 跟箱子的作法一样。每个槽位对应的Slot数量如下: 例： 一个熔炉的方块实体NBT: 讲台 id: (String) &quot;Lectern”跑不掉 isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 page: (Integer) 目前该讲台展示的书本所在的页数。本标签仅在讲台有书的时候才会被保存。 totalPages: (Integer) 该讲台展示的书本总页数本标签仅在讲台有书的时候才会被保存。 hasBook: (Byte) 这个讲台是否有书在上面，有就是1。本标签仅在讲台有书的时候才会被保存。 book: (Compound) 这里保存了展示的书的物品NBT。 例： 一个放置了书的讲台（上）和一个没有放书的讲台（下）: 信标 id: (String) &quot;Beacon” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 primary: (Integer) 信标的第一级效果应用的药水效果id【跟java版的作用一样~省了我好多实验的时间】 Secondary: (Integer) 信标的第二级效果应用的药水效果id 注：如果&quot;primary&quot;和&quot;Secondary&quot;的值相同，那么效果就会变成二级的。 附赠一张基岩版的药水效果对应id表~: ​ ​ 许许多多的信标，猜猜ta们的对应效果叭~: 刷怪笼 id: (String) &quot;MobSpawner” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 EntityIdentifier: (String) 该刷怪笼生成的怪物id, 例: &quot;minecraft:polar_bear&quot;。当该刷怪笼是空时，这个值为空。 MinSpawnDelay, MaxSpawnDelay: (Short) 该刷怪笼的最小和最大的刷怪间隔 RequiredPlayerRange: (Short) 当玩家在刷怪笼几格内时，刷怪笼才会尝试去生成生物（即冒烟（ SpawnRange: (Short) 【自己讲不清楚...找维基, 然后改一改】刷怪笼可以随机生成实体的范围。生成区域为正方体，含刷怪笼所在的方块。生物将会随机生成在以刷怪笼的 X、Z 坐标和以刷怪笼底部的Y坐标为中心的2格高的区域。 MaxNearbyEntities: (Short) 刷怪笼尝试生成生物时，刷怪笼周围的最大实体数量。 SpawnCount: (Short) 刷怪笼每次尝试生成生物的尝试数量（因为在游戏体验中，有时候刷怪笼并不会每次都会生成4个怪物） Delay: (Short) 下一次生成生物的时间离现在有多少游戏tick。当玩家距离刷怪笼的长度满足刷怪笼的生成条件且刷怪笼内部有刷怪蛋时，这个值才会刷新。刷新这个值，即取在最小刷怪间隔和最大刷怪间隔之间取一个随机数。 DisplayEntityHeight, DisplayEntityScale, DisplayEntityWidth: (Float) 需要证实： 游戏每次尝试生成生物时，会以DisplayEntityWidth为长和宽，DisplayEntityHeight为高的矩形去测试某个地方是否会生成生物。 例: 一个被修改过的空的刷怪箱: 音符盒 id: (String) &quot;Music” 第一个与对应的方块的英文名字不一样的id! isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 note: (Byte) 该音符的音高。通俗来讲就是玩家敲击了几次音符盒。如图: 例：一个被敲击了一次的音符盒的方块实体NBT标签: 唱片机 id: (String) &quot;Jukebox” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 RecordItem: (Compound) 是该唱片内部存储的唱片物品的NBT。当这个唱片机里面没有唱片时，则没有这一项。 例：上方是内部存有游戏里没有的唱片的唱片机，下方是没有唱片的: 【雪莉：现在时间是8月31号晚上9点18分，似乎...算了，抓紧吧，以后来作业了又...】 伸出的活塞臂 id: (String) &quot;PistonArm” Sticky: (Byte) 活塞臂是否是黏糊糊的（粘性活塞） 研究这个比较困难，因为活塞伸出的时间就只有那么长，想要踩点对我来说还是很困难的。于是下面就直接展示自己的研究过程吧。 ​ 首先我摆放了四个活塞，一个不伸出，一个伸出来，还有一个伸到一半，最后一个缩回来一半(怎么说起来那么奇怪呢)。并对比两者中有何变化。以下是有变化的项(在我的测试时): ​ 【呜呜呜┭┮﹏┭┮获得这些数据花了我好久因为我是手残QwQ 所以那个按钮之类的...Awq】 ​ 【部分数据是猜测 不过大概率肯定是对的 【啊...手残党...】】 ​ 【我的测试是将粘性活塞放在[ 4, 8, 11 ]的地方，将[ 4, 8, 10 ]的方块来回推，下表从左到右展示了这个过程】 项的名称 活塞臂未伸出时的值 活塞臂正在伸出时的值 活塞臂伸出时的值 活塞臂正在缩回时的值 isMovable 1 1 1 0 0 0 LastProgress 0 0 0.5 1 1 0.5 Progress 0 0.5 1 1 0.5 0 State 0 1 1 2 3 3 NewState 0 1 1 2 3 3 AttachedBlocks [] [ 4, 8, 10 ] [ 4, 8, 10 ] [] [ 4, 8, 9 ] [ 4, 8, 9 ] 【22点21了...】 ​ 其实还有一个项，&quot;BreakBlocks&quot;。猜测是由于我的测试一直都是推方块，所以这个值一直都没用到【要那样测试的话...我已经在233层高楼上面准备把空气当床了】。估计这个BreakBlocks如果使用到了的话，相同的情况对应的跟上面的movingBlocks的值是相同的。 ​ 研究发现，当粘性的活塞臂正在伸出时，其AttachedBlocks会的值为其活塞臂粘着的方块还未被推动时的原坐标；当粘性的活塞臂正在缩回时，其AttachedBlocks会的值为其活塞臂粘着的方块还未被拉回时的原坐标。 ​ 由于测试太过繁琐，所以我们来直接推测一下如果不是粘性活塞而是普通的活塞，那么这些值会怎么变化。推测：其它值都随着上面的走，但AttachedBlocks只在活塞推动了一个方块时才会有值。 ​ 【幸亏测试的是粘性活塞呀，不然...233层高楼我来了】 ​ 排除了这些项之后，,,,，好像就没有其ta项了嘻嘻(●'◡'●) 直接进入下一个。 正在被活塞移动的方块：当上面活塞臂的state是1或3时才会出现这个类型的实体方块。 id: (String) &quot;MovingBlock” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 movingBlock: (Compound) 记录了这个movingBlock的方块NBT movingBlockExtra: (Compound) 记录了一个方块NBT，在自己的实验中好像一直是air的方块nbt。TODO: 尝试用活塞去拉史莱姆方块粘着的方块看看这个值。 ​ 既然跟活塞运动有关【不要想歪真的没有那种意思】，我们就使用跟研究活塞一样的列表思路。下表记录的仍然是有变化的量。 ​ 【部分数据是猜测 不过大概率肯定是对的 【啊...手残党... *2】】 ​ 【我的测试是将粘性活塞放在[ 4, 8, 11 ]的地方，将[ 4, 8, 10 ]的红石块来回推，下表从左到右展示了这个过程】 ​ 【什么？宁认为我又会去做一遍实验? Oh no~ 我在做实验时发现了这个MovingBlock，在做上面的实验的时候顺便也记下来惹~~~~】 【第二天晚上】 项的名称 活塞臂未伸出时的值 活塞臂正在伸出时的值 活塞臂伸出时的值 活塞臂正在缩回时的值 State (这个是复制的上面一个表 方便记录) 0 1 1 2 3 3 pistonPosX, pistonPosY, pistonPosZ [] [ 4, 8, 11 ] [ 4, 8, 11 ] [] [ 4, 8, 11 ] [ 4, 8, 11 ] x, y, z [] [ 4, 8, 9 ] [ 4, 8, 9 ] [] [ 4, 8, 10 ] [ 4, 8, 10 ] ​ 于是可以得出普遍规律: 当出现这个实体方块NBT时，pistonPosX, pistonPosY, pistonPosZ指向的坐标总是推这个方块的活塞；当活塞正在推ta时，x, y, z指向的坐标是这个实体方块将被推到的坐标，反之，当活塞正在拉ta时，x，y，z指向的是这个实体方块将被拉回到的坐标。 ​ 为了猜测movingBlockExtra的用途，我打算继续做一个实验: ​ 当我用史莱姆方块拉着一个方块让活塞臂进行伸缩运动时，红石块出现的MovingBlock方块实体NBT内，pistonPosX, pistonPosY, pistonPosZ仍然是推拉史莱姆方块的活塞的坐标。movingBlockExtra仍然是空气的方块NBT。 【屑博主仍然在学校写完了几乎所有作业的第三个晚上】 附魔台 id: (String) &quot;EnchantTable” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 rott: (Float) 似乎跟漂浮的书有关，不清楚规律。 末地传送门 id: (String) &quot;EndPortal” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 末影箱 id: (String) &quot;EnderChest” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 items: (List) 猜测应该是末影箱里面存放的东西，但是观测一直是长度为0的空列表 头颅 id: (String) &quot;Skull” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 SkullType: (Byte) 头颅类型，如下表: SkullType 类型 0 骷髅 1 凋零骷髅 2 僵尸 3 玩家 4 Creeper? 5 末影龙 MouthMoving: (Byte) 嘴巴是否动，应该只对末影龙头有效 MouthTickCount: (Integer) 单位是游戏tick，跟嘴巴动的动画有关。 Rotation: (Float) 头颅的摆放方向 命令方块 id: (String) &quot;CommandBlock” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 ExecuteOnFirstTick: (Byte) 指定循环型命令方块是否在激活后立即执行其命令。如果为0，则从激活时起延迟延迟时间后再执行；为1则会在激活时立即执行命令。 auto: (Byte) 当这个值为1时，该命令方块选项界面的“红石”将会是“始终活动&quot;选项。即【引用Wiki: 命令方块甚至在没有红石信号时也会保持为开启状态 （连锁型命令方块将在感应后执行命令， 循环型命令方块将在每一游戏刻执行一次命令（每秒20次），脉冲型命令方块在设置完毕后将立即激活，且此后将无法再次执行）】 TickDelay: (Integer) 即命令方块界面中的“已选择的延迟” 【附上维基上面对于“已选择的延迟”的解释：对于脉冲型命令方块和连锁型命令方块，“已选择的延迟”的值即在被激活或触发后，执行命令之前延迟的游戏刻。对于循环型命令方块，“已选择的延迟”的值即其循环执行指令中间间隔的的游戏刻。注意：对于脉冲型命令方块和循环型命令方块，延迟设置为0和1的效果相同，游戏将把0视为1】 Command: (String) 该命令方块的命令 conditionMet: (Byte) 1或0（是/否）- 指示条件命令块在上次激活时是否满足其条件。如果不是条件命令块，则为1【维基是这样说，但是仍然发现了不是条件命令块且也为0的情况】 LastExecution: (Long) 这个命令方块最后被成功执行的游戏刻 LastOutputParams: (List) 观察这里是长度为3的列表（即这个列表里面有三项） LastOutput: (String) 这里是指向语言文件的一个索引。程序yuan为了方便做国际化，会将游戏中出现的文字都变成一段特定的字符和符号组合，在游戏的代码中就引用这个字符串，在不同语言的语言文件就去定义这个字符串的值，展示在玩家面前的就是其对应语言的文字；如果这串文字没有在语言文件里面找到对应的值，就会原模原样的呈现在玩家面前 在找到的对应文字里面，会有一些比较奇怪的东西，比如说”%1$s”“%2$d”。如果大家学过C语言，可能会意识到，里面的&quot;$s&quot;指的是一个字符串，对应C语言的&quot;%s&quot;；&quot;$d&quot;是一个整数，即对应&quot;%d&quot;。的确（的猜测），这里的&quot;$&quot;之后跟的对应的就是C语言中“%”后面跟的。同理，也可以发现，里面“%”后面跟的数字就是上面的“LastOutputParams”列表的项数（这个项数不是从0开始数的！从1开始）。 SuccessCount: (Integer) 该命令方块用红石比较器输出的模拟信号强度 CustomName: (String) 即命令方块界面中的“悬停说明”。当指针指向该命令方块时可以在方块上面看到它，也可以用在说话方面的指令上面，比如说&quot;say&quot;：默认没有写悬停说明的时候会在说话内容之前的中括号里面写上一个大大的感叹号，否则就会写上”悬停说明“里面对应的文字。【可以制造出有人在说话的效果，在RPG等剧情类的游戏中比较常用】 LPCommandMode: (Integer) 即命令方块界面中的“上一个输出”下面的”方块类型“。0是脉冲，1是重复，2是连锁。 LPCondionalMode: (Byte) 即命令方块界面中的“上一个输出”下面的”条件“。0是无条件，其它值都当作有条件。 LPRedstoneMode: (Byte) 即命令方块界面中的“上一个输出”下面的”红石“。0是始终活动，其它值都当作需要红石。 TrackOutput: (Byte) 即命令方块界面中的“上一个输出”开关。0是关，此时LPCommandMode，LPCondionalMode，LPRedstoneMode这三个值的不存在不会造成游戏崩溃；其它值都是开，若这三个值的不存在，游戏会重置这三个值到默认的初始状态，即三个0。 powered: (Byte) 是否有在被充能。游戏在刷新区块时会刷新检测一个方块是否被充能，接下来再检测&quot;powered&quot;值是否为1，如果不为1，则执行这个命令方块，然后将&quot;powered&quot;值设置为1。 Version: (Integer) 应该是命令方块在存档中存储的格式的版本号 方便游戏在下一次更新这个格式时判定是否需要将本地的格式升级，在1.16.40版本观测是”12“。 【开学后的第一个周末】 ​ 例: 一个命令方块的界面与其在存档中的存储 末地折跃门 id: (String) &quot;EndGateway” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 ExitPortal: (List) 一个长度为3的整型数组，代表一个坐标，指向这个末地折跃门的传送坐标。 Age: (Integer) 这个传送门已经激活了多少个游戏刻。当这个值大于0且小于200时，折跃门会发出紫红色的信标光柱。当这个值超过Integer类型所能表示的最大数时，游戏仍然会将这个数自增，然后程序yuan们就知道会发生什么了。这个数会一直自增，只要玩家在刷新范围里面，这就是说，有生之年还可以看到一个末地折跃门在静默状态启动第二次，亮起第二次有点基的颜色光柱，想想就心动呀（个鬼） 拼图方块 id: (String) &quot;JigsawBlock” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 name: (String) 即拼图方块界面中的“名称” target: (String) 即拼图方块界面中的“目标名称” target_pool: (String) 即拼图方块界面中的“目标池” final_state: (String) 即拼图方块界面中的“变为” joint: (String) 即拼图方块界面中的“接点类型”。rollable是”可滚动&quot;， aligned是“一致”。其它值都会被视作可滚动。 ​ 例: 一个拼图的界面与其在存档中的存储 结构方块 id: (String) &quot;StructureBlock” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 data: (Integer) 结构方块的模式。默认值是1，即保存。 0 1 2 3 4 5 其他值 Boom~ 闪退~ dateField: (String) 默认值是空，好像没什么作用的样子 ignoreEntities: (Byte) 默认值是0，即忽略实体 ignorePlayers: (Byte) 默认值是0，忽略玩家？游戏中好像没有关于这个的设置 integrity: (Float) 默认值是100，即加载界面的完整性 isPowered: (Byte) 默认值是0，是否有在被红石充能（压力马斯内~ 即答） mirror: (Byte) 默认值是0。这个值对应的是加载模式下面的镜像选项： 0 1 2 3 redstoneSaveMode: (Integer) 默认值是0。保存至内存是0，保存至磁盘是1 removeBlocks: (Byte) 默认值是0，对应的是“移除方块”选项。关闭移除方块是0，开启移除方块是1 rotation: (Byte) 默认值是0，对应的是加载模式下的“旋转&quot;: 0 1 2 3 seed: (Long) 默认值是0，即加载界面的”种子&quot;文本框 showBoundingBox: (Byte) 默认值是1，即“显示边界盒”开关。1是开，0是关 structureName: (String) 默认值是空，即“建筑名称”文本框里的内容 xStructureOffset, yStructureOffset, zStructureOffset: (Integer) 三个数分别代表“偏移”标签下面的x，y，z。默认值是[ 0, -1, 0 ] xStructureSize, yStructureSize, zStructureSize: (Integer) 三个数分别代表“保存”模式中“大小”标签下面的x，y，z。默认值是[ 0, -1, 0 ] 例: 一个结构方块的界面与其在存档中的存储 【又该清空背包了，雪莉酱不假思索的在聊天列表里面打出了&quot;/cls&quot;】 下界核心 虽然也是实体方块但是这个版本不知道怎么去获得，修改了之后由于游戏中下界反应核的功能代码被删掉了，修改就失去意义了，外置的Add-on应该也实现不了修改方块实体NBT，所以就直接跳过吧。 阳光传感器 id: (String) &quot;DaylightDetector” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 【没错 就只有这么多/xk】 花盆 id: (String) &quot;FlowerPot” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 PlantBlock: (Compound) 花盆里面放的花的方块NBT 红石比较器 id: (String) &quot;Comparator” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 OutputSignal: (Integer) 该红石比较器输出的红石信号 床🛏: 上半部分床和下半部分床分开存储 id: (String) &quot;Bed” isMovable: (Byte) 是否能被活塞推动，默认是1，即能推动。0是不能被推动。 color: (Byte) 床的颜色。如果两个床在方块实体中存储的颜色不相同，则取上半部分床为床的颜色。这个值所对应的颜色如下表： 炼药锅： 在方块实体，只存储炼药锅内的水的属性；水位在方块状态NBT里面存储 id: (String) &quot;Cauldron” isMovable: (Byte) 是否能被活塞推动。默认是1，即能推动；0是不能被推动。 Items: (List) 不清楚是干什么用的 [ ~- ^ -~ ] CustomColor: (Integer) 当炼药锅里面是水，且已经被染色的时候，这个标签才存在。这个标签虽然看起来是一个Integer类型的整数，但是实际使用的时候是将这个整数拆分成四个字节，分别对应RGBA四个颜色数值。 这是一个装满粉色染料染过色之后的水的炼药锅的CustomColor值: PotionType: (Short) 该药水的类型。0是普通药水，1是喷溅型药水，2是滞留性药水。如果炼药锅内装的不是药水，这里会写-1. Potionid: (Short) 该药水的种类。如果炼药锅内装的不是药水，这里会是-1。其ta的药水对应如下表： 潮涌核心 id: (String) &quot;Conduit” isMovable: (Byte) 是否能被活塞推动。默认是1，即能推动；0是不能被推动。 Active: (Byte) 该潮涌核心是否启动。0代表没启动，反之则1. Target: (Long) 潮涌核心正在攻击的生物的uuid 铃🔔 【维基上面说是跟铃的动画有关，但由于这个动画时间短，修改之后可能在游戏加载的时候铃的动画状态就还原了，所以,,,】 id: (String) &quot;Bell” isMovable: (Byte) 是否能被活塞推动。默认是1，即能推动；0是不能被推动。 Ringing: (Byte) 该铃声是否在响。1为是，0为非。 Ticks: (Integer) 从前一次敲击或放置这个铃开始数的游戏刻。 Direction: (Integer) 当铃静止不动时，这个值是255. 子区块的数据 ​ 其实获取子区块不仅仅只是传一个“47”。因为在游戏中，子区块是从下到上堆积起来的，像堆积木一样。一个子区块的大小是16*16*16，所以我们需要在我们的“47”后面再接上一个byte类型（在下面就称这个数this_num辽）。这个byte类型的数字范围是[ 0, 15 ]【即0 &lt;= this_num&lt;= 15】，代表这个子区块是从最下面一个子区块向上数的第this_num个的子区块。所以这个子区块的y轴范围是[ this_num * 16, (this_num + 1) * 16 )【即 this_num * 16 &lt;= y轴范围 &lt; (this_num + 1) * 16】。 ​ 上面买了个小关子，这回我们终于拿到想要的地形存储了。再加上Python爬虫，爬取播放量多的midi文件并解析，最后再将红石音乐的样式生成做成一个Interface，唔，美汁汁~ 接下来，宁可能会被映入眼帘的获取到的杂乱的数据昏了头脑；用MCC ToolChest PE的读者，一定也会发现，在一个区块里面，似乎没有被提及的就是Sections这个列表了。这个列表里面又有几个子对象，宁可能会马上意识到，这就是我们这一节要调教的子区块，然后就会被迷住（😂） ​ 我们先从MCC ToolChest开始讲起，因为ta有一个可视化的界面。没有装MCC ToolChest的同学也不要紧，我这里放上我的测试世界的某一个区块的MCC ToolChest界面： ​ 还有这个区块代表的区块截图： ​ 将所有的标签都展开，我们就可以发现，这个子区块中的Palette存储的是这个子区块所有类型方块的方块NBT。那么为什么要这样存呢？脑袋转的快的同学马上就能反应出来，游戏为了压缩世界大小，将所有类型的方块状态存在一个列表里面，那么存储方块就是存储这个方块在列表里面的索引。存储的少，算法还简单，读写就更快了，两全其美。然后下面的BlockStates就是这个子区块的每一个方块对应的索引。 ​ 这就是我们的假说，接下来我们要做的就是将上面的BlockStates导出，变成一张表，然后将这张表对着Palette中的项去对照。我们就取有熔炉的那一层，是第58层，即这个子区块的第58 % 16 = 10层。按照每一层16 * 16 = 256个方块，每个方块的索引占一个Integer即4个字节，我们就得取偏移了(10 - 1) * (256 * 4) = 9216字节之后的1024字节： 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 2 2 2 5 0 0 0 0 0 0 0 0 0 0 0 2 12 10 11 2 0 0 0 0 0 0 0 0 0 0 0 2 14 0 0 6 0 0 0 0 0 0 0 0 0 0 0 2 15 15 0 2 0 0 0 0 0 0 0 0 0 0 0 5 2 2 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ​ 不难将其根据Palette转换成图：【由于这里看不出来床的颜色 所以默认使用白色】 【床尾】 【床头】 ​ 接下来与原版进行对比: ​ 因为盔甲架是实体，不算方块，所以就可以看到，算是完全一致。那么这个假说算是可以证明成立了。【大家可以替换掉几个方块，多实验几次，毕竟只实验一次具有偶然性，这里为了节省篇幅就不多做实验了】 ","link":"https://lovelyzeeiam.github.io/post/minecraft-bedrock-level-format/"}]}